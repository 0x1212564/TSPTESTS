       
# Restaurant Waiter Route Optimization

This project implements and compares different algorithms for solving the Traveling Salesman Problem (TSP) in the context of restaurant waiters delivering food to tables. The goal is to find the optimal route for a waiter starting from the kitchen, visiting all tables exactly once, and returning to the kitchen while minimizing the total distance traveled.

## Project Structure

- `tsp_algorithms.py`: Core implementations of all TSP algorithms
- `tsp_main.py`: Main entry point with command-line interface
- `tsp_benchmark.py`: Benchmarking functionality to compare algorithm performance
- `tsp_unit_tests.py`: Comprehensive test suite for all algorithms

## Usage

### Running the Algorithms

```bash
# Run all algorithms on the large restaurant dataset (default)
python tsp_main.py

# Run on a specific restaurant size
python tsp_main.py --restaurant small
python tsp_main.py --restaurant medium
python tsp_main.py --restaurant large
python tsp_main.py --restaurant larger
python tsp_main.py --restaurant mega

# Run without visualization
python tsp_main.py --no-visualize
```

### Running the Benchmark

```bash
python tsp_main.py --benchmark
```

This will run all algorithms on all dataset sizes, measure performance, and generate comparison charts saved as:
- `tsp_benchmark_results.csv`: Raw benchmark data
- `tsp_benchmark_results.png`: Computation time and route quality comparison
- `tsp_growth_rate.png`: Route distance growth by problem size

## Visualization

The project can visualize the routes generated by each algorithm. Visualizations include:
- The complete route with direction arrows
- Kitchen highlighted as a green square
- Tables as red dots
- Total route distance

Visualization files are saved as `route_{size}_{algorithm}.png`.

Run the tests with:

```bash
python -m unittest tsp_unit_tests.py
```

## Dataset Generation

The project generates synthetic restaurant layouts with tables randomly distributed around a central kitchen:
- Small: 6 tables
- Medium: 12 tables
- Large: 20 tables
- Larger: 50 tables
- Mega: 100 tables

## Performance Considerations

- Brute Force is only practical for very small instances (â‰¤10 tables)
- Nearest Neighbor is very fast but produces suboptimal solutions
- 2-opt Local Search offers a good balance of speed and solution quality
- Genetic Algorithm and Simulated Annealing can find high-quality solutions for large instances

## Dependencies

- NumPy: For numerical operations and array handling
- Matplotlib: For visualization
- Python 3.6+: For type hints and modern language features
        Too many current requests. Your queue position is 2. Please wait for a while or switch to other models for a smoother experience.
